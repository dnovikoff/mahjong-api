// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/service.proto

package api

import (
	context "context"
	fmt "fmt"
	log "github.com/dnovikoff/mahjong-api/genproto/log"
	rules "github.com/dnovikoff/mahjong-api/genproto/rules"
	proto "github.com/golang/protobuf/proto"
	duration "github.com/golang/protobuf/ptypes/duration"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type PlayerType int32

const (
	PlayerType_PLAYER_TYPE_UNSPECIFIED PlayerType = 0
	// Expects that player will connect with Play method
	PlayerType_CLIENT PlayerType = 1
	// Predefined robots
	// Drops taken tiles
	PlayerType_ROBOT_TSUMOGIRI PlayerType = 2
	// Robot will try to play according to uke-ire
	PlayerType_ROBOT_EFFECTIVE PlayerType = 3
)

var PlayerType_name = map[int32]string{
	0: "PLAYER_TYPE_UNSPECIFIED",
	1: "CLIENT",
	2: "ROBOT_TSUMOGIRI",
	3: "ROBOT_EFFECTIVE",
}

var PlayerType_value = map[string]int32{
	"PLAYER_TYPE_UNSPECIFIED": 0,
	"CLIENT":                  1,
	"ROBOT_TSUMOGIRI":         2,
	"ROBOT_EFFECTIVE":         3,
}

func (x PlayerType) String() string {
	return proto.EnumName(PlayerType_name, int32(x))
}

func (PlayerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_42c32aec9010f89c, []int{0}
}

type MessageSource int32

const (
	MessageSource_SOURCE_TYPE_UNSPECIFIED MessageSource = 0
	// Message produced by robot, replacing the offline player.
	MessageSource_SOURCE_ROBOT MessageSource = 1
	// Message resulted by settings on server side. Ex. AutoWin
	MessageSource_SOURCE_SETTINGS MessageSource = 2
	// Message produced by players action.
	MessageSource_SOURCE_CLIENT MessageSource = 3
	// Message produced by timeout on server side.
	MessageSource_SOURCE_TIMEOUT MessageSource = 4
)

var MessageSource_name = map[int32]string{
	0: "SOURCE_TYPE_UNSPECIFIED",
	1: "SOURCE_ROBOT",
	2: "SOURCE_SETTINGS",
	3: "SOURCE_CLIENT",
	4: "SOURCE_TIMEOUT",
}

var MessageSource_value = map[string]int32{
	"SOURCE_TYPE_UNSPECIFIED": 0,
	"SOURCE_ROBOT":            1,
	"SOURCE_SETTINGS":         2,
	"SOURCE_CLIENT":           3,
	"SOURCE_TIMEOUT":          4,
}

func (x MessageSource) String() string {
	return proto.EnumName(MessageSource_name, int32(x))
}

func (MessageSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_42c32aec9010f89c, []int{1}
}

type GetLogRequest struct {
	LogId                string   `protobuf:"bytes,1,opt,name=log_id,json=logId,proto3" json:"log_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetLogRequest) Reset()         { *m = GetLogRequest{} }
func (m *GetLogRequest) String() string { return proto.CompactTextString(m) }
func (*GetLogRequest) ProtoMessage()    {}
func (*GetLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_42c32aec9010f89c, []int{0}
}

func (m *GetLogRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetLogRequest.Unmarshal(m, b)
}
func (m *GetLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetLogRequest.Marshal(b, m, deterministic)
}
func (m *GetLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLogRequest.Merge(m, src)
}
func (m *GetLogRequest) XXX_Size() int {
	return xxx_messageInfo_GetLogRequest.Size(m)
}
func (m *GetLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLogRequest proto.InternalMessageInfo

func (m *GetLogRequest) GetLogId() string {
	if m != nil {
		return m.LogId
	}
	return ""
}

type ListRulesRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListRulesRequest) Reset()         { *m = ListRulesRequest{} }
func (m *ListRulesRequest) String() string { return proto.CompactTextString(m) }
func (*ListRulesRequest) ProtoMessage()    {}
func (*ListRulesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_42c32aec9010f89c, []int{1}
}

func (m *ListRulesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListRulesRequest.Unmarshal(m, b)
}
func (m *ListRulesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListRulesRequest.Marshal(b, m, deterministic)
}
func (m *ListRulesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRulesRequest.Merge(m, src)
}
func (m *ListRulesRequest) XXX_Size() int {
	return xxx_messageInfo_ListRulesRequest.Size(m)
}
func (m *ListRulesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRulesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRulesRequest proto.InternalMessageInfo

type GetRuleRequest struct {
	RuleId               string   `protobuf:"bytes,1,opt,name=rule_id,json=ruleId,proto3" json:"rule_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetRuleRequest) Reset()         { *m = GetRuleRequest{} }
func (m *GetRuleRequest) String() string { return proto.CompactTextString(m) }
func (*GetRuleRequest) ProtoMessage()    {}
func (*GetRuleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_42c32aec9010f89c, []int{2}
}

func (m *GetRuleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetRuleRequest.Unmarshal(m, b)
}
func (m *GetRuleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetRuleRequest.Marshal(b, m, deterministic)
}
func (m *GetRuleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetRuleRequest.Merge(m, src)
}
func (m *GetRuleRequest) XXX_Size() int {
	return xxx_messageInfo_GetRuleRequest.Size(m)
}
func (m *GetRuleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetRuleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetRuleRequest proto.InternalMessageInfo

func (m *GetRuleRequest) GetRuleId() string {
	if m != nil {
		return m.RuleId
	}
	return ""
}

type ListRulesResponse struct {
	Rules                []*rules.Ruleset `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ListRulesResponse) Reset()         { *m = ListRulesResponse{} }
func (m *ListRulesResponse) String() string { return proto.CompactTextString(m) }
func (*ListRulesResponse) ProtoMessage()    {}
func (*ListRulesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_42c32aec9010f89c, []int{3}
}

func (m *ListRulesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListRulesResponse.Unmarshal(m, b)
}
func (m *ListRulesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListRulesResponse.Marshal(b, m, deterministic)
}
func (m *ListRulesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRulesResponse.Merge(m, src)
}
func (m *ListRulesResponse) XXX_Size() int {
	return xxx_messageInfo_ListRulesResponse.Size(m)
}
func (m *ListRulesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRulesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListRulesResponse proto.InternalMessageInfo

func (m *ListRulesResponse) GetRules() []*rules.Ruleset {
	if m != nil {
		return m.Rules
	}
	return nil
}

type Player struct {
	// Name displayed
	Caption string `protobuf:"bytes,1,opt,name=caption,proto3" json:"caption,omitempty"`
	// Should not fill in request. Will be filled in reply
	// Could be any string, generated by server. Client should not rely on id format.
	Token                string     `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	PlayerType           PlayerType `protobuf:"varint,3,opt,name=player_type,json=playerType,proto3,enum=api.PlayerType" json:"player_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Player) Reset()         { *m = Player{} }
func (m *Player) String() string { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()    {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_42c32aec9010f89c, []int{4}
}

func (m *Player) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Player.Unmarshal(m, b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Player.Marshal(b, m, deterministic)
}
func (m *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(m, src)
}
func (m *Player) XXX_Size() int {
	return xxx_messageInfo_Player.Size(m)
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

func (m *Player) GetCaption() string {
	if m != nil {
		return m.Caption
	}
	return ""
}

func (m *Player) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *Player) GetPlayerType() PlayerType {
	if m != nil {
		return m.PlayerType
	}
	return PlayerType_PLAYER_TYPE_UNSPECIFIED
}

// There is no auth at the moment.
// Fields are options, still please provide at least some information to contact you.
type CreatorInfo struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Email                string   `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
	Telegram             string   `protobuf:"bytes,3,opt,name=telegram,proto3" json:"telegram,omitempty"`
	Vk                   string   `protobuf:"bytes,4,opt,name=vk,proto3" json:"vk,omitempty"`
	Facebook             string   `protobuf:"bytes,5,opt,name=facebook,proto3" json:"facebook,omitempty"`
	Github               string   `protobuf:"bytes,6,opt,name=github,proto3" json:"github,omitempty"`
	Other                string   `protobuf:"bytes,7,opt,name=other,proto3" json:"other,omitempty"`
	Purpose              string   `protobuf:"bytes,8,opt,name=purpose,proto3" json:"purpose,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreatorInfo) Reset()         { *m = CreatorInfo{} }
func (m *CreatorInfo) String() string { return proto.CompactTextString(m) }
func (*CreatorInfo) ProtoMessage()    {}
func (*CreatorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_42c32aec9010f89c, []int{5}
}

func (m *CreatorInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreatorInfo.Unmarshal(m, b)
}
func (m *CreatorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreatorInfo.Marshal(b, m, deterministic)
}
func (m *CreatorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreatorInfo.Merge(m, src)
}
func (m *CreatorInfo) XXX_Size() int {
	return xxx_messageInfo_CreatorInfo.Size(m)
}
func (m *CreatorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CreatorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CreatorInfo proto.InternalMessageInfo

func (m *CreatorInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreatorInfo) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *CreatorInfo) GetTelegram() string {
	if m != nil {
		return m.Telegram
	}
	return ""
}

func (m *CreatorInfo) GetVk() string {
	if m != nil {
		return m.Vk
	}
	return ""
}

func (m *CreatorInfo) GetFacebook() string {
	if m != nil {
		return m.Facebook
	}
	return ""
}

func (m *CreatorInfo) GetGithub() string {
	if m != nil {
		return m.Github
	}
	return ""
}

func (m *CreatorInfo) GetOther() string {
	if m != nil {
		return m.Other
	}
	return ""
}

func (m *CreatorInfo) GetPurpose() string {
	if m != nil {
		return m.Purpose
	}
	return ""
}

// Format for storing logs. (Private usage)
type StorageLog struct {
	Log       *log.Log             `protobuf:"bytes,1,opt,name=log,proto3" json:"log,omitempty"`
	CreatedAt *timestamp.Timestamp `protobuf:"bytes,2,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// Storing information of created request
	Create *CreateRequest `protobuf:"bytes,3,opt,name=create,proto3" json:"create,omitempty"`
	// Debug information for investigations
	PlayerMessages       []*DebugMessages `protobuf:"bytes,4,rep,name=player_messages,json=playerMessages,proto3" json:"player_messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *StorageLog) Reset()         { *m = StorageLog{} }
func (m *StorageLog) String() string { return proto.CompactTextString(m) }
func (*StorageLog) ProtoMessage()    {}
func (*StorageLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_42c32aec9010f89c, []int{6}
}

func (m *StorageLog) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageLog.Unmarshal(m, b)
}
func (m *StorageLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageLog.Marshal(b, m, deterministic)
}
func (m *StorageLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageLog.Merge(m, src)
}
func (m *StorageLog) XXX_Size() int {
	return xxx_messageInfo_StorageLog.Size(m)
}
func (m *StorageLog) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageLog.DiscardUnknown(m)
}

var xxx_messageInfo_StorageLog proto.InternalMessageInfo

func (m *StorageLog) GetLog() *log.Log {
	if m != nil {
		return m.Log
	}
	return nil
}

func (m *StorageLog) GetCreatedAt() *timestamp.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *StorageLog) GetCreate() *CreateRequest {
	if m != nil {
		return m.Create
	}
	return nil
}

func (m *StorageLog) GetPlayerMessages() []*DebugMessages {
	if m != nil {
		return m.PlayerMessages
	}
	return nil
}

type DebugMessages struct {
	Messages             []*DebugMessage `protobuf:"bytes,1,rep,name=messages,proto3" json:"messages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DebugMessages) Reset()         { *m = DebugMessages{} }
func (m *DebugMessages) String() string { return proto.CompactTextString(m) }
func (*DebugMessages) ProtoMessage()    {}
func (*DebugMessages) Descriptor() ([]byte, []int) {
	return fileDescriptor_42c32aec9010f89c, []int{7}
}

func (m *DebugMessages) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DebugMessages.Unmarshal(m, b)
}
func (m *DebugMessages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DebugMessages.Marshal(b, m, deterministic)
}
func (m *DebugMessages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugMessages.Merge(m, src)
}
func (m *DebugMessages) XXX_Size() int {
	return xxx_messageInfo_DebugMessages.Size(m)
}
func (m *DebugMessages) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugMessages.DiscardUnknown(m)
}

var xxx_messageInfo_DebugMessages proto.InternalMessageInfo

func (m *DebugMessages) GetMessages() []*DebugMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type DebugMessage struct {
	Time *timestamp.Timestamp `protobuf:"bytes,1,opt,name=time,proto3" json:"time,omitempty"`
	// Types that are valid to be assigned to OneofEvents:
	//	*DebugMessage_Client
	//	*DebugMessage_Server
	OneofEvents          isDebugMessage_OneofEvents `protobuf_oneof:"oneof_events"`
	Source               MessageSource              `protobuf:"varint,4,opt,name=source,proto3,enum=api.MessageSource" json:"source,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *DebugMessage) Reset()         { *m = DebugMessage{} }
func (m *DebugMessage) String() string { return proto.CompactTextString(m) }
func (*DebugMessage) ProtoMessage()    {}
func (*DebugMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_42c32aec9010f89c, []int{8}
}

func (m *DebugMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DebugMessage.Unmarshal(m, b)
}
func (m *DebugMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DebugMessage.Marshal(b, m, deterministic)
}
func (m *DebugMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DebugMessage.Merge(m, src)
}
func (m *DebugMessage) XXX_Size() int {
	return xxx_messageInfo_DebugMessage.Size(m)
}
func (m *DebugMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DebugMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DebugMessage proto.InternalMessageInfo

func (m *DebugMessage) GetTime() *timestamp.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

type isDebugMessage_OneofEvents interface {
	isDebugMessage_OneofEvents()
}

type DebugMessage_Client struct {
	Client *Client `protobuf:"bytes,2,opt,name=client,proto3,oneof"`
}

type DebugMessage_Server struct {
	Server *Server `protobuf:"bytes,3,opt,name=server,proto3,oneof"`
}

func (*DebugMessage_Client) isDebugMessage_OneofEvents() {}

func (*DebugMessage_Server) isDebugMessage_OneofEvents() {}

func (m *DebugMessage) GetOneofEvents() isDebugMessage_OneofEvents {
	if m != nil {
		return m.OneofEvents
	}
	return nil
}

func (m *DebugMessage) GetClient() *Client {
	if x, ok := m.GetOneofEvents().(*DebugMessage_Client); ok {
		return x.Client
	}
	return nil
}

func (m *DebugMessage) GetServer() *Server {
	if x, ok := m.GetOneofEvents().(*DebugMessage_Server); ok {
		return x.Server
	}
	return nil
}

func (m *DebugMessage) GetSource() MessageSource {
	if m != nil {
		return m.Source
	}
	return MessageSource_SOURCE_TYPE_UNSPECIFIED
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*DebugMessage) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*DebugMessage_Client)(nil),
		(*DebugMessage_Server)(nil),
	}
}

// The method of creating games is a subject to change.
type CreateRequest struct {
	// Types that are valid to be assigned to OneofRules:
	//	*CreateRequest_Rules
	//	*CreateRequest_RuleId
	OneofRules isCreateRequest_OneofRules `protobuf_oneof:"oneof_rules"`
	Timeouts   *rules.Timeouts            `protobuf:"bytes,3,opt,name=timeouts,proto3" json:"timeouts,omitempty"`
	// Should provide at least one Client player
	// Provide players in order, correspondig their EAST1 starting positions
	Players []*Player `protobuf:"bytes,4,rep,name=players,proto3" json:"players,omitempty"`
	// For debugging purposes and robots.
	// If provided - game will end after one round.
	// The conditions could be predefined.
	// If wall defined - will replace the wall with given values.
	// The number of tiles in wall could be reduced to at least 5 tiles.
	// Still all tiles should remain unique.
	// The exact number of tiles for indicators is 5.
	// The exact number of tiles for rinshan is 4.
	SingleRound *log.RoundInfo `protobuf:"bytes,5,opt,name=single_round,json=singleRound,proto3" json:"single_round,omitempty"`
	Creator     *CreatorInfo   `protobuf:"bytes,6,opt,name=creator,proto3" json:"creator,omitempty"`
	// Redefine random seed for predictable game
	Seed *wrappers.Int64Value `protobuf:"bytes,7,opt,name=seed,proto3" json:"seed,omitempty"`
	// Just output the result, with no actual game created (validation)
	DryRun               bool     `protobuf:"varint,8,opt,name=dry_run,json=dryRun,proto3" json:"dry_run,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateRequest) Reset()         { *m = CreateRequest{} }
func (m *CreateRequest) String() string { return proto.CompactTextString(m) }
func (*CreateRequest) ProtoMessage()    {}
func (*CreateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_42c32aec9010f89c, []int{9}
}

func (m *CreateRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateRequest.Unmarshal(m, b)
}
func (m *CreateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateRequest.Marshal(b, m, deterministic)
}
func (m *CreateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateRequest.Merge(m, src)
}
func (m *CreateRequest) XXX_Size() int {
	return xxx_messageInfo_CreateRequest.Size(m)
}
func (m *CreateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateRequest proto.InternalMessageInfo

type isCreateRequest_OneofRules interface {
	isCreateRequest_OneofRules()
}

type CreateRequest_Rules struct {
	Rules *rules.Ruleset `protobuf:"bytes,1,opt,name=rules,proto3,oneof"`
}

type CreateRequest_RuleId struct {
	RuleId string `protobuf:"bytes,2,opt,name=rule_id,json=ruleId,proto3,oneof"`
}

func (*CreateRequest_Rules) isCreateRequest_OneofRules() {}

func (*CreateRequest_RuleId) isCreateRequest_OneofRules() {}

func (m *CreateRequest) GetOneofRules() isCreateRequest_OneofRules {
	if m != nil {
		return m.OneofRules
	}
	return nil
}

func (m *CreateRequest) GetRules() *rules.Ruleset {
	if x, ok := m.GetOneofRules().(*CreateRequest_Rules); ok {
		return x.Rules
	}
	return nil
}

func (m *CreateRequest) GetRuleId() string {
	if x, ok := m.GetOneofRules().(*CreateRequest_RuleId); ok {
		return x.RuleId
	}
	return ""
}

func (m *CreateRequest) GetTimeouts() *rules.Timeouts {
	if m != nil {
		return m.Timeouts
	}
	return nil
}

func (m *CreateRequest) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *CreateRequest) GetSingleRound() *log.RoundInfo {
	if m != nil {
		return m.SingleRound
	}
	return nil
}

func (m *CreateRequest) GetCreator() *CreatorInfo {
	if m != nil {
		return m.Creator
	}
	return nil
}

func (m *CreateRequest) GetSeed() *wrappers.Int64Value {
	if m != nil {
		return m.Seed
	}
	return nil
}

func (m *CreateRequest) GetDryRun() bool {
	if m != nil {
		return m.DryRun
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CreateRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CreateRequest_Rules)(nil),
		(*CreateRequest_RuleId)(nil),
	}
}

type CreateResponse struct {
	// ID of created game. Later used to get log ID.
	// Could be any string, generated by server. Client should not rely on id format.
	GameId string         `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	Rules  *rules.Ruleset `protobuf:"bytes,2,opt,name=rules,proto3" json:"rules,omitempty"`
	// Client players will be given tokens to join the game
	Players []*Player `protobuf:"bytes,3,rep,name=players,proto3" json:"players,omitempty"`
	// Please play the game in a given time
	Ttl                  *duration.Duration `protobuf:"bytes,4,opt,name=ttl,proto3" json:"ttl,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *CreateResponse) Reset()         { *m = CreateResponse{} }
func (m *CreateResponse) String() string { return proto.CompactTextString(m) }
func (*CreateResponse) ProtoMessage()    {}
func (*CreateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_42c32aec9010f89c, []int{10}
}

func (m *CreateResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CreateResponse.Unmarshal(m, b)
}
func (m *CreateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CreateResponse.Marshal(b, m, deterministic)
}
func (m *CreateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateResponse.Merge(m, src)
}
func (m *CreateResponse) XXX_Size() int {
	return xxx_messageInfo_CreateResponse.Size(m)
}
func (m *CreateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateResponse proto.InternalMessageInfo

func (m *CreateResponse) GetGameId() string {
	if m != nil {
		return m.GameId
	}
	return ""
}

func (m *CreateResponse) GetRules() *rules.Ruleset {
	if m != nil {
		return m.Rules
	}
	return nil
}

func (m *CreateResponse) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *CreateResponse) GetTtl() *duration.Duration {
	if m != nil {
		return m.Ttl
	}
	return nil
}

func init() {
	proto.RegisterEnum("api.PlayerType", PlayerType_name, PlayerType_value)
	proto.RegisterEnum("api.MessageSource", MessageSource_name, MessageSource_value)
	proto.RegisterType((*GetLogRequest)(nil), "api.GetLogRequest")
	proto.RegisterType((*ListRulesRequest)(nil), "api.ListRulesRequest")
	proto.RegisterType((*GetRuleRequest)(nil), "api.GetRuleRequest")
	proto.RegisterType((*ListRulesResponse)(nil), "api.ListRulesResponse")
	proto.RegisterType((*Player)(nil), "api.Player")
	proto.RegisterType((*CreatorInfo)(nil), "api.CreatorInfo")
	proto.RegisterType((*StorageLog)(nil), "api.StorageLog")
	proto.RegisterType((*DebugMessages)(nil), "api.DebugMessages")
	proto.RegisterType((*DebugMessage)(nil), "api.DebugMessage")
	proto.RegisterType((*CreateRequest)(nil), "api.CreateRequest")
	proto.RegisterType((*CreateResponse)(nil), "api.CreateResponse")
}

func init() { proto.RegisterFile("api/service.proto", fileDescriptor_42c32aec9010f89c) }

var fileDescriptor_42c32aec9010f89c = []byte{
	// 1087 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x56, 0xdb, 0x6e, 0xdb, 0x46,
	0x10, 0x35, 0x25, 0x99, 0x92, 0x87, 0x96, 0x2c, 0x6f, 0x9a, 0x98, 0x51, 0x80, 0xd6, 0x20, 0x1a,
	0xc3, 0x75, 0x60, 0x2a, 0x51, 0x83, 0x02, 0x69, 0x81, 0x02, 0xb1, 0x4d, 0x3b, 0x04, 0x7c, 0xc3,
	0x8a, 0x0e, 0x90, 0xbe, 0x08, 0x6b, 0x71, 0x45, 0x33, 0xa6, 0xb8, 0x2c, 0xb9, 0x74, 0xe1, 0xfe,
	0x4e, 0x1f, 0xfb, 0x21, 0xed, 0x43, 0xbf, 0xa1, 0xdf, 0x52, 0xec, 0x85, 0x92, 0x7c, 0x69, 0x5e,
	0x04, 0xce, 0xcc, 0xd9, 0x9d, 0x9d, 0x33, 0x37, 0xc1, 0x3a, 0xc9, 0xe2, 0x7e, 0x41, 0xf3, 0x9b,
	0x78, 0x4c, 0xdd, 0x2c, 0x67, 0x9c, 0xa1, 0x3a, 0xc9, 0xe2, 0xde, 0x37, 0x11, 0x63, 0x51, 0x42,
	0xfb, 0x52, 0x75, 0x59, 0x4e, 0xfa, 0x3c, 0x9e, 0xd2, 0x82, 0x93, 0x69, 0xa6, 0x50, 0xbd, 0xaf,
	0xef, 0x03, 0xc2, 0x32, 0x27, 0x3c, 0x66, 0xe9, 0xff, 0xd9, 0x7f, 0xcb, 0x49, 0x96, 0xd1, 0xbc,
	0xd0, 0xf6, 0xae, 0x70, 0x3c, 0x4e, 0x62, 0x9a, 0xf2, 0x45, 0x8d, 0x78, 0x0a, 0xcd, 0xb5, 0xa6,
	0x9d, 0xb0, 0xa8, 0x9f, 0xb0, 0x48, 0x8b, 0xeb, 0x79, 0x99, 0xd0, 0xa2, 0x2f, 0x7f, 0x95, 0xca,
	0xd9, 0x82, 0xf6, 0x11, 0xe5, 0xc7, 0x2c, 0xc2, 0xf4, 0xd7, 0x92, 0x16, 0x1c, 0x3d, 0x05, 0x33,
	0x61, 0xd1, 0x28, 0x0e, 0x6d, 0x63, 0xd3, 0xd8, 0x5e, 0xc1, 0xcb, 0x09, 0x8b, 0xfc, 0xd0, 0x41,
	0xd0, 0x3d, 0x8e, 0x0b, 0x8e, 0xc5, 0x51, 0x0d, 0x75, 0xbe, 0x83, 0xce, 0x11, 0x95, 0xaa, 0xea,
	0xf0, 0x06, 0x34, 0xc5, 0xe5, 0xf3, 0xd3, 0xa6, 0x10, 0xfd, 0xd0, 0x79, 0x07, 0xeb, 0x0b, 0xc7,
	0x8b, 0x8c, 0xa5, 0x05, 0x45, 0xdf, 0xc2, 0xb2, 0x7c, 0x8a, 0x6d, 0x6c, 0xd6, 0xb7, 0xad, 0x41,
	0xc7, 0x55, 0x0f, 0x93, 0x20, 0xca, 0xb1, 0x32, 0x3a, 0x9f, 0xc1, 0x3c, 0x4f, 0xc8, 0x2d, 0xcd,
	0x91, 0x0d, 0xcd, 0x31, 0xc9, 0x04, 0x45, 0xfa, 0xf6, 0x4a, 0x44, 0x5f, 0xc1, 0x32, 0x67, 0xd7,
	0x34, 0xb5, 0x6b, 0xea, 0xcd, 0x52, 0x40, 0xaf, 0xc1, 0xca, 0xe4, 0xc9, 0x11, 0xbf, 0xcd, 0xa8,
	0x5d, 0xdf, 0x34, 0xb6, 0x3b, 0x83, 0x35, 0x97, 0x64, 0xb1, 0xab, 0x6e, 0x0c, 0x6e, 0x33, 0x8a,
	0x21, 0x9b, 0x7d, 0x3b, 0x7f, 0x19, 0x60, 0xed, 0xe7, 0x94, 0x70, 0x96, 0xfb, 0xe9, 0x84, 0x21,
	0x04, 0x8d, 0x94, 0x4c, 0xa9, 0x76, 0x27, 0xbf, 0x85, 0x2f, 0x3a, 0x25, 0x71, 0x52, 0xf9, 0x92,
	0x02, 0xea, 0x41, 0x8b, 0xd3, 0x84, 0x46, 0x39, 0x99, 0x4a, 0x47, 0x2b, 0x78, 0x26, 0xa3, 0x0e,
	0xd4, 0x6e, 0xae, 0xed, 0x86, 0xd4, 0xd6, 0x6e, 0xae, 0x05, 0x76, 0x42, 0xc6, 0xf4, 0x92, 0xb1,
	0x6b, 0x7b, 0x59, 0x61, 0x2b, 0x19, 0x3d, 0x03, 0x33, 0x8a, 0xf9, 0x55, 0x79, 0x69, 0x9b, 0x8a,
	0x40, 0x25, 0x09, 0xaf, 0x8c, 0x5f, 0xd1, 0xdc, 0x6e, 0x2a, 0xaf, 0x52, 0x10, 0x8c, 0x64, 0x65,
	0x9e, 0xb1, 0x82, 0xda, 0x2d, 0xc5, 0x88, 0x16, 0x9d, 0x7f, 0x0c, 0x80, 0x21, 0x67, 0x39, 0x89,
	0xe8, 0x31, 0x8b, 0x50, 0x0f, 0xea, 0x09, 0x8b, 0x64, 0x1c, 0xd6, 0xa0, 0xe5, 0x8a, 0x92, 0x10,
	0x39, 0x17, 0x4a, 0xf4, 0x0e, 0x60, 0x2c, 0x62, 0xa6, 0xe1, 0x88, 0x70, 0x19, 0x95, 0x35, 0xe8,
	0xb9, 0xaa, 0xfa, 0xdc, 0xaa, 0xfa, 0xdc, 0xa0, 0x2a, 0x5f, 0xbc, 0xa2, 0xd1, 0xef, 0x39, 0xda,
	0x01, 0x53, 0x09, 0x32, 0x66, 0x6b, 0x80, 0x24, 0xb9, 0x92, 0xc1, 0xaa, 0x26, 0xb0, 0x46, 0xa0,
	0x9f, 0x60, 0x4d, 0x67, 0x63, 0x4a, 0x8b, 0x82, 0x44, 0xb4, 0xb0, 0x1b, 0x32, 0xef, 0xea, 0xd0,
	0x01, 0xbd, 0x2c, 0xa3, 0x13, 0x6d, 0xc1, 0x1d, 0x05, 0xad, 0x64, 0xe7, 0x67, 0x68, 0xdf, 0x01,
	0xa0, 0x5d, 0x68, 0xcd, 0xae, 0x51, 0xe5, 0xb3, 0xfe, 0xe0, 0x1a, 0x3c, 0x83, 0x38, 0x7f, 0x1b,
	0xb0, 0xba, 0x68, 0x42, 0x2e, 0x34, 0x44, 0x43, 0x6a, 0x46, 0xbe, 0x14, 0xae, 0xc4, 0xa1, 0x97,
	0x60, 0xaa, 0x5e, 0xd3, 0x04, 0x59, 0x2a, 0x52, 0xa9, 0xfa, 0xb0, 0x84, 0xb5, 0x51, 0xc0, 0x54,
	0x03, 0x6a, 0x42, 0x14, 0x6c, 0x28, 0x55, 0x02, 0xa6, 0x8c, 0x82, 0xb7, 0x82, 0x95, 0xf9, 0x98,
	0xca, 0xaa, 0xe8, 0x68, 0x0a, 0xf4, 0xdb, 0x86, 0xd2, 0x82, 0x35, 0x62, 0xaf, 0x03, 0xab, 0x2c,
	0xa5, 0x6c, 0x32, 0xa2, 0x37, 0x34, 0xe5, 0x85, 0xf3, 0x6f, 0x0d, 0xda, 0x77, 0x18, 0x46, 0x5b,
	0xf3, 0x3e, 0x32, 0x1e, 0xf6, 0xd1, 0x87, 0x25, 0xdd, 0x49, 0xe8, 0xf9, 0xbc, 0x3b, 0x65, 0xed,
	0x8a, 0x07, 0xa9, 0xfe, 0x44, 0xaf, 0xa0, 0x25, 0xc2, 0x64, 0x25, 0x2f, 0xf4, 0xcb, 0xd7, 0xf4,
	0x2d, 0x81, 0x56, 0xe3, 0x19, 0x00, 0xbd, 0x84, 0xa6, 0x4a, 0x4f, 0x95, 0x41, 0x6b, 0xa1, 0xa7,
	0x70, 0x65, 0x43, 0x6f, 0x60, 0xb5, 0x88, 0xd3, 0x28, 0xa1, 0xa3, 0x9c, 0x95, 0x69, 0x28, 0x4b,
	0x5d, 0xbc, 0x4e, 0x14, 0x1f, 0x16, 0x1a, 0xd1, 0x62, 0xd8, 0x52, 0x18, 0xa9, 0x40, 0x3b, 0xd0,
	0x1c, 0xab, 0xf6, 0x93, 0xe5, 0x6f, 0x0d, 0xba, 0xf3, 0x82, 0x52, 0x2d, 0x89, 0x2b, 0x00, 0xea,
	0x43, 0xa3, 0xa0, 0x34, 0x94, 0x0d, 0x61, 0x0d, 0x5e, 0x3c, 0xc8, 0xa0, 0x9f, 0xf2, 0x1f, 0xde,
	0x7e, 0x24, 0x49, 0x49, 0xb1, 0x04, 0x8a, 0xe1, 0x14, 0xe6, 0xb7, 0xa3, 0xbc, 0x4c, 0x65, 0xb3,
	0xb4, 0xb0, 0x19, 0xe6, 0xb7, 0xb8, 0x4c, 0xf7, 0xda, 0x60, 0x29, 0x86, 0xd5, 0xc0, 0xf9, 0xc3,
	0x80, 0x4e, 0x45, 0xb0, 0x9e, 0x54, 0x1b, 0xd0, 0x8c, 0xc8, 0x74, 0x71, 0xae, 0x09, 0xd1, 0x0f,
	0xe7, 0x23, 0xac, 0xf6, 0x18, 0xf5, 0x15, 0xf1, 0x0b, 0x84, 0xd5, 0xbf, 0x40, 0xd8, 0x2b, 0xa8,
	0x73, 0x9e, 0xc8, 0x92, 0xb0, 0x06, 0xcf, 0x1f, 0x04, 0x74, 0xa0, 0xf7, 0x03, 0x16, 0xa8, 0x9d,
	0x11, 0xc0, 0x7c, 0x88, 0xa1, 0x17, 0xb0, 0x71, 0x7e, 0xfc, 0xfe, 0x93, 0x87, 0x47, 0xc1, 0xa7,
	0x73, 0x6f, 0x74, 0x71, 0x3a, 0x3c, 0xf7, 0xf6, 0xfd, 0x43, 0xdf, 0x3b, 0xe8, 0x2e, 0x21, 0x00,
	0x73, 0xff, 0xd8, 0xf7, 0x4e, 0x83, 0xae, 0x81, 0x9e, 0xc0, 0x1a, 0x3e, 0xdb, 0x3b, 0x0b, 0x46,
	0xc1, 0xf0, 0xe2, 0xe4, 0xec, 0xc8, 0xc7, 0x7e, 0xb7, 0x36, 0x57, 0x7a, 0x87, 0x87, 0xde, 0x7e,
	0xe0, 0x7f, 0xf4, 0xba, 0xf5, 0x9d, 0xdf, 0xa1, 0x7d, 0xa7, 0x20, 0x85, 0x8f, 0xe1, 0xd9, 0x05,
	0xde, 0xf7, 0x1e, 0xf3, 0xd1, 0x85, 0x55, 0x6d, 0x94, 0x37, 0x29, 0x4f, 0x5a, 0x33, 0xf4, 0x82,
	0xc0, 0x3f, 0x3d, 0x1a, 0x76, 0x6b, 0x68, 0x1d, 0xda, 0x5a, 0xa9, 0x5f, 0x54, 0x47, 0x08, 0x3a,
	0xd5, 0xb5, 0xfe, 0x89, 0x77, 0x76, 0x11, 0x74, 0x1b, 0x83, 0x3f, 0x6b, 0xd0, 0x38, 0x12, 0xc3,
	0xf6, 0x47, 0x58, 0x99, 0xed, 0x0d, 0xf4, 0x54, 0xb2, 0x76, 0x7f, 0x0d, 0xf5, 0x9e, 0xdd, 0x57,
	0xeb, 0xa4, 0xb9, 0xd0, 0xd4, 0xeb, 0x09, 0x3d, 0x91, 0x90, 0xbb, 0xcb, 0xaa, 0x77, 0x2f, 0x59,
	0x68, 0x0b, 0x4c, 0xb5, 0x0a, 0x11, 0xaa, 0xe0, 0xf3, 0xbd, 0xd8, 0x9b, 0x0d, 0x4d, 0xf4, 0x56,
	0xae, 0xcc, 0x85, 0xe1, 0xfa, 0x18, 0x5c, 0xad, 0x99, 0x05, 0xd0, 0x1b, 0x30, 0x55, 0x51, 0xa1,
	0x47, 0x86, 0x64, 0xef, 0xc9, 0x1d, 0x9d, 0x0e, 0x60, 0x0b, 0x1a, 0x22, 0xc5, 0x68, 0x71, 0xd6,
	0xf4, 0x16, 0x27, 0x8a, 0xb3, 0xb4, 0x6d, 0xbc, 0x36, 0xf6, 0xfa, 0xbf, 0xec, 0xaa, 0x2d, 0xe1,
	0x8e, 0xd9, 0xb4, 0x1f, 0xa6, 0xec, 0x26, 0xbe, 0x66, 0x93, 0x49, 0x7f, 0x4a, 0xae, 0x3e, 0xb3,
	0x34, 0xda, 0x15, 0x7f, 0x0b, 0x22, 0x9a, 0xca, 0x42, 0xea, 0x93, 0x2c, 0xbe, 0x34, 0xe5, 0xe7,
	0xf7, 0xff, 0x05, 0x00, 0x00, 0xff, 0xff, 0x12, 0x3d, 0x08, 0x01, 0xbc, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GameClient is the client API for Game service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GameClient interface {
	ListRules(ctx context.Context, in *ListRulesRequest, opts ...grpc.CallOption) (*ListRulesResponse, error)
	GetRule(ctx context.Context, in *GetRuleRequest, opts ...grpc.CallOption) (*rules.Ruleset, error)
	// At the moment, logs are stored in memory, and might be lost in some time.
	// In future will be stored on disk/db.
	GetLog(ctx context.Context, in *GetLogRequest, opts ...grpc.CallOption) (*log.Log, error)
	// Creator info truncated at return
	GetStorageLog(ctx context.Context, in *GetLogRequest, opts ...grpc.CallOption) (*StorageLog, error)
	Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error)
	// Use tokens, gained in Create to auth Play via "token" header
	Play(ctx context.Context, opts ...grpc.CallOption) (Game_PlayClient, error)
}

type gameClient struct {
	cc *grpc.ClientConn
}

func NewGameClient(cc *grpc.ClientConn) GameClient {
	return &gameClient{cc}
}

func (c *gameClient) ListRules(ctx context.Context, in *ListRulesRequest, opts ...grpc.CallOption) (*ListRulesResponse, error) {
	out := new(ListRulesResponse)
	err := c.cc.Invoke(ctx, "/api.Game/ListRules", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameClient) GetRule(ctx context.Context, in *GetRuleRequest, opts ...grpc.CallOption) (*rules.Ruleset, error) {
	out := new(rules.Ruleset)
	err := c.cc.Invoke(ctx, "/api.Game/GetRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameClient) GetLog(ctx context.Context, in *GetLogRequest, opts ...grpc.CallOption) (*log.Log, error) {
	out := new(log.Log)
	err := c.cc.Invoke(ctx, "/api.Game/GetLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameClient) GetStorageLog(ctx context.Context, in *GetLogRequest, opts ...grpc.CallOption) (*StorageLog, error) {
	out := new(StorageLog)
	err := c.cc.Invoke(ctx, "/api.Game/GetStorageLog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameClient) Create(ctx context.Context, in *CreateRequest, opts ...grpc.CallOption) (*CreateResponse, error) {
	out := new(CreateResponse)
	err := c.cc.Invoke(ctx, "/api.Game/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gameClient) Play(ctx context.Context, opts ...grpc.CallOption) (Game_PlayClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Game_serviceDesc.Streams[0], "/api.Game/Play", opts...)
	if err != nil {
		return nil, err
	}
	x := &gamePlayClient{stream}
	return x, nil
}

type Game_PlayClient interface {
	Send(*Client) error
	Recv() (*Server, error)
	grpc.ClientStream
}

type gamePlayClient struct {
	grpc.ClientStream
}

func (x *gamePlayClient) Send(m *Client) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gamePlayClient) Recv() (*Server, error) {
	m := new(Server)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// GameServer is the server API for Game service.
type GameServer interface {
	ListRules(context.Context, *ListRulesRequest) (*ListRulesResponse, error)
	GetRule(context.Context, *GetRuleRequest) (*rules.Ruleset, error)
	// At the moment, logs are stored in memory, and might be lost in some time.
	// In future will be stored on disk/db.
	GetLog(context.Context, *GetLogRequest) (*log.Log, error)
	// Creator info truncated at return
	GetStorageLog(context.Context, *GetLogRequest) (*StorageLog, error)
	Create(context.Context, *CreateRequest) (*CreateResponse, error)
	// Use tokens, gained in Create to auth Play via "token" header
	Play(Game_PlayServer) error
}

func RegisterGameServer(s *grpc.Server, srv GameServer) {
	s.RegisterService(&_Game_serviceDesc, srv)
}

func _Game_ListRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServer).ListRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Game/ListRules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServer).ListRules(ctx, req.(*ListRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Game_GetRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServer).GetRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Game/GetRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServer).GetRule(ctx, req.(*GetRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Game_GetLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServer).GetLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Game/GetLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServer).GetLog(ctx, req.(*GetLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Game_GetStorageLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServer).GetStorageLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Game/GetStorageLog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServer).GetStorageLog(ctx, req.(*GetLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Game_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GameServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Game/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GameServer).Create(ctx, req.(*CreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Game_Play_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GameServer).Play(&gamePlayServer{stream})
}

type Game_PlayServer interface {
	Send(*Server) error
	Recv() (*Client, error)
	grpc.ServerStream
}

type gamePlayServer struct {
	grpc.ServerStream
}

func (x *gamePlayServer) Send(m *Server) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gamePlayServer) Recv() (*Client, error) {
	m := new(Client)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Game_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Game",
	HandlerType: (*GameServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListRules",
			Handler:    _Game_ListRules_Handler,
		},
		{
			MethodName: "GetRule",
			Handler:    _Game_GetRule_Handler,
		},
		{
			MethodName: "GetLog",
			Handler:    _Game_GetLog_Handler,
		},
		{
			MethodName: "GetStorageLog",
			Handler:    _Game_GetStorageLog_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Game_Create_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Play",
			Handler:       _Game_Play_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "api/service.proto",
}
